#+title: readme
#+property: header-args:nim+ :flags -d:plainStdout --cc:tcc --hints:off
#+property: header-args:nim+ :import hparse/doc_example

Collection of variout utilities related to parsing, ranging from
statically typed wrapper on top of ~scanf~ to full parser generator
(with support for EBNF notation, tree actions, template rules,
compile/runtime parsing and automatic parse tree generation)

* Small utilities

** ~tscanf~

** ~rx~ macro

* Parser generator

Parser generator focuses on *simplicity* and *ease of use*. Concrete
implementation details of particular parser algorithms are hidden as
much as possible - you can [fn::this is the WIP part, but the ultimate
goal] easily swap parsing algorithms without altering your grammar at
all.

** Grammar description

Grammar described using EBNF notation, with only exception being use
of prefix notation - e.g. for zero-or-more you need to write ~*E~.

Example of very simple grammar grammar:

#+caption: repeated 'hello world' grammar
#+begin_src nim
  let grammar = initGrammar[NoCategory, string]:
    A ::= *("hello" & "world")
#+end_src

More complex example (with result tree)

#TODO generate tree

#+caption: Nested list grammar
#+begin_src nim :exports both
  exampleGrammarConst(grammar):
    List ::= !"[" & Elements & !"]"
    Elements ::= Element & @*(@(!"," & Element))
    Element ::= "i" | List

  let parser = exampleParser(grammar)
  var stream = "[i,i,[i,i,i],i]".mapIt($it).makeTokens().makeStream()
  let tree = parser.parse(stream)
  echo tree.treeRepr()
#+end_src

#+RESULTS:
#+begin_example
+-> List
    +-> Elements
        +-> Element +-> 'i'
        +-> Element +-> 'i'
        +-> Element
        |   +-> List
        |       +-> Elements
        |           +-> Element +-> 'i'
        |           +-> Element +-> 'i'
        |           +-> Element +-> 'i'
        +-> Element +-> 'i'
#+end_example

*** Nonterminals

** Tree actions

Result of parser generator is a =parse tree= - very representation of
original source code and contains all helper symbols (punctition,
brackets, precedense levels etc). All of this cruft is necessary to
correctly recognize input sequence of tokens, but completely
irrelevant afterwards - in nested list grammar only ~Elements~ are
actually necessary, everything else can be thrown away immediately.
*Tree actions* are intended for this exact purpose - dropping
unnecessary parts of the parse tree, flattening out nested parts etc.
Currently five types of actions are supported.

#TODO example of each tree action

*** Drop

*** Splice discard

Add subnode elements in parent tree


*** Splice promote

*** Subrule

*** Promote

** Parse templates

#TODO DOC

Some patterns often occur in grammar construction - list with
delimiters, kv pairs etc. Even though grammar is pretty simple,
writing something like ~Element & @*(@(!"," & Element))~ over and over
again is not really fun. Parse templates are designed to solve this
issue.

- [ ] example of parse template
- [ ] explanation of internal grammar implementation
- [ ] dsl syntax description


** Token description

#TODO DOC

* Integration with other libraries

- Conversion of parse tree to graphviz representation using
  =hasts/graphviz_ast=

* Development

** Rationale

** Design overview

** State of development

Parser generator is currently work-in-progress. All advertized
features are implemented, but number of supported algorithms is
lacking - fully supported is only backtracking ~LL(*)~. Codegen and
table-driven ~LL(1)~ are partially supported (have some weird bugs).
Some work has been done on adding ~SLR~ and ~Earley~ parser.

Parser generator has relatively clean and documented internal API,
designed to make implementation of new algorithms as simple as
possible (lost of details are abstracted).

** Contribution

All sorts of contributions are welcome - issues, unit tests,
documentation updates etc.

In addition there are several things that I wasn't able to implement
myself. If you are interested to solve one of there problems it will
be especially useful.

If you have any question about implementation details, API etc. you
can join my [[https://discord.gg/ZnBB4E][discord server]].

*** Earley parser

When implementing ~Earley~ parser I mostly followed [[http://loup-vaillant.fr/tutorials/earley-parsing/][this]] tutorial - it
has example implementation in ocaml and very nice explanation of most
algorithm parts, except for tree construction itself. My very limited
knowled of =ocaml= wasn't enough to fully rewrite it in =nim=.
Standalone rewrite is in [[file:src/hparse/earley_parser.nim]] - it does
not depend on any other library parts (can copy-paste on playground
and it will run just fine).

This parser algorithm is much more powerful compared to recursive
descent and even shift-reduce parsers. It can handle left recursion,
ambiguous and nullable rules.


** Unsolved problems


*** Fix tree after EBNF -> BNF rewriting

Only recursive descent parsers can accept EBNF notation as-is. Every
other one requires conversion from EBNF to BNF (implemented, tested).
The problem is - this trasnformation changes shape of the parsed tree.
For example ~A ::= *(E)~ is converted to ~A ::= E1~ and ~E1 ::= Ɛ | E
E1~ - recursion is replaced with iteration.

#TODO add grammar transformation example
#TODO add parsed tree.

#TODO IDEA add support for ~block~ sessions - code will be wrapped
into ~block:~ (or alternative for other programming language).

#+caption: Grammar
#+begin_src nim
exampleConstGrammar:
  A ::= *("hello")

let llRecParser = newLL1RecursiveParser(grammar)
let llTableParser = newLL1TableParser(grammar) # TODO add overloaded constructor for example
#+end_src

#+begin_src nim
let tree1 = @["hello", "!!", "!!", "!!", "world"].exampleParse:
  A ::= "hello" & *(B) & "world"
  B ::= "!!"

echo "Recursive descent tree"
echo tree1.treeRepr()

echo "Table-driven parser tree"
let tree2 = @["hello", "!!", "!!", "!!", "world"].exampleParseBNF_noFix:
  A ::= "hello" & *(B) & "world"
  B ::= "!!"

echo tree2.treeRepr()
#+end_src

#+RESULTS:
#+begin_example
Recursive descent tree
+-> A
    +-> 'hello'
    +-> [ [ ... ] ]
    |   +-> B +-> '!!'
    |   +-> B +-> '!!'
    |   +-> B +-> '!!'
    +-> 'world'
Table-driven parser tree
+-> A
    +-> 'hello'
    +-> [ [ ... ] ]
    |   +-> B +-> '!!'
    |   +-> B +-> '!!'
    |   +-> B +-> '!!'
    +-> [ [ ... ] ]
#+end_example

* DSL error reporting

DSL for this library uses =hmisc/hexceptions= to generate *much*
better compilation errors in case of malformed DSL.

#+begin_src nim :exports both
let tree = "h".exampleParse:
  A ::= !@*("h")

echo tree.treeRepr()
#+end_src

#+RESULTS:
#+begin_example
Unexpected prefix: '!@*'

 2   let tree = "h".exampleParse:
 5:8   A ::= !@*("h")
             ^^^
             |
             Incorrect prefix combination



Raised in grammar_dsl.nim:105


 [CodeError:ObjectType]
#+end_example


NOTE: output is not colored in readme (because github [[https://github.com/github/markup/issues/369][fails]] to support
this basic feature *since 2014*), but it is colored by default
terminal (controlled by using ~-d:plainStdout~ compilation flag)

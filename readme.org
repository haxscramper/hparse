#+title: readme
#+property: header-args:nim+ :flags -d:plainStdout --cc:tcc --hints:off
#+property: header-args:nim+ :import hparse/doc_example

Collection of variout utilities related to parsing, ranging from
statically typed wrapper on top of ~scanf~ to full parser generator
(with support for EBNF notation, tree actions, template rules,
compile/runtime parsing and automatic parse tree generation)

* Small utilities

** ~tscanf~

** ~rx~ macro

* Parser generator

Parser generator focuses on *simplicity* and *ease of use*. Concrete
implementation details of particular parser algorithms are hidden as
much as possible - you can [fn::this is the WIP part, but the ultimate
goal] easily swap parsing algorithms without altering your grammar at
all.

** Grammar description

Grammar described using EBNF notation, with only exception being use
of prefix notation - e.g. for zero-or-more you need to write ~*E~.

Example of very simple grammar grammar:

#+caption: repeated 'hello world' grammar
#+begin_src nim
  let grammar = initGrammar[NoCategory, string]:
    A ::= *("hello" & "world")
#+end_src

More complex example (with result tree)

#TODO generate tree

#+caption: Nested list grammar
#+begin_src nim :exports both
  exampleGrammarConst(grammar):
    List ::= !"[" & Elements & !"]"
    Elements ::= Element & @*(@(!"," & Element))
    Element ::= "i" | List

  let parser = exampleParser(grammar)
  var stream = "[i,i,[i,i,i],i]".mapIt($it).makeTokens().makeStream()
  let tree = parser.parse(stream)
  echo tree.treeRepr()
#+end_src

#+RESULTS:
#+begin_example
+-> List
    +-> Elements
        +-> Element +-> 'i'
        +-> Element +-> 'i'
        +-> Element
        |   +-> List
        |       +-> Elements
        |           +-> Element +-> 'i'
        |           +-> Element +-> 'i'
        |           +-> Element +-> 'i'
        +-> Element +-> 'i'
#+end_example

*** DSL syntax

**** EBNF prefix

- ~*~ zero-or-more
- ~+~ one-or-more
- ~?~ optional

**** Tree actions prefix

- ~!~ drop
- ~@~ splice-discard
- ~^~ promote
- ~^@~ splice-promote

**** Prefix combinations

# NOTE i'm really not sure about these actions: I need to figure out
# how they should work. Promoting multiple elements at once?


# - "^@*" :: splice-promote zero-or-more
# - "^@+" :: splice-promote zero-or-more
# - "^*" :: promote zero-or-more
# - "^+" :: promote one-or-more
# - "@?" :: splice optional
# - "^@?" :: splice-promote optional

- ~!*~  drop zero-or-more elements
- ~!+~  drop one-or-more
- ~@+~  splice one-or-more
- ~@*~  splice zero-or-more
- ~!?~  drop optional
- ~^?~  prmote optional

Invalid combinations: ~"*!", "+!", "*@", "+@", "*^@", "+^@", "+^", "*^"~

**** Delimiters




*** Nonterminals

** Tree actions

Result of parser generator is a =parse tree= - very representation of
original source code and contains all helper symbols (punctition,
brackets, precedense levels etc). All of this cruft is necessary to
correctly recognize input sequence of tokens, but completely
irrelevant afterwards - in nested list grammar only ~Elements~ are
actually necessary, everything else can be thrown away immediately.
*Tree actions* are intended for this exact purpose - dropping
unnecessary parts of the parse tree, flattening out nested parts etc.
Currently five types of actions are supported.

*** Drop

Completely remove subtree element

#+begin_src nim :exports both
  echo ecompare(@["a", "b", "c"]) do:
    A ::= "a" & "b" & "c"
  do:
    A ::= "a" & !"b" & "c"
#+end_src

#+RESULTS:
: +-> A        +-> A
:     +-> 'a'      +-> 'a'
:     +-> 'b'      +-> 'c'
:     +-> 'c'

*** Splice discard

Add subnode elements in parent tree. Subtree head is removed.

#+begin_src nim :exports both
  echo ecompare(@["-", "+", "+", "+", "-"]) do:
    A ::= "-" & *"+" & "-"
  do:
    A ::= "-" & @*"+" & "-"
#+end_src

#+RESULTS:
: +-> A                +-> A
:     +-> '-'              +-> '-'
:     +-> [ [ ... ] ]      +-> '+'
:     |   +-> '+'          +-> '+'
:     |   +-> '+'          +-> '+'
:     |   +-> '+'          +-> '-'
:     +-> '-'


*** Splice promote

Splice all node node elements and replace parent node. NOTE: this
replaces only *parent* node - in expression like ~"-" & ^@B~ parent
node for ~B~ is concatenation - not nonterminal head. ~A~

#+begin_src nim :exports both
  echo ecompare(@["-", "+", "+", "+"]) do:
    A ::= "-" & B
    B ::= *"+"
  do:
    A ::= "-" & ^@B
    B ::= *"+"
#+end_src

#+RESULTS:
: +-> A            +-> A
:     +-> '-'          +-> B
:     +-> B                +-> '-'
:         +-> '+'          +-> '+'
:         +-> '+'          +-> '+'
:         +-> '+'          +-> '+'

*** Subrule

Move part of the tree into separate list

#+begin_src nim :exports both
  echo ecompare(@["-", "z", "e"]) do:
    A ::= "-" & "z" & "e"
  do:
    A ::= "-" & { "z" & "e" }
#+end_src

#+RESULTS:
: +-> A        +-> A
:     +-> '-'      +-> '-'
:     +-> 'z'      +-> [ [ ... ] ]
:     +-> 'e'          +-> 'z'
:                      +-> 'e'

*** Promote

** Parse templates

#TODO DOC

Some patterns often occur in grammar construction - list with
delimiters, kv pairs etc. Even though grammar is pretty simple,
writing something like ~Element & @*(@(!"," & Element))~ over and over
again is not really fun. Parse templates are designed to solve this
issue.

- [ ] example of parse template
- [ ] explanation of internal grammar implementation
- [ ] dsl syntax description


** Token description

#TODO DOC

* Integration with other libraries

- Conversion of parse tree to graphviz representation using
  =hasts/graphviz_ast=

* Development

** Rationale

** Design overview

** State of development

Parser generator is currently work-in-progress. All advertized
features are implemented, but number of supported algorithms is
lacking - fully supported is only backtracking ~LL(*)~. Codegen and
table-driven ~LL(1)~ are partially supported (have some weird bugs).
Some work has been done on adding ~SLR~ and ~Earley~ parser.

Parser generator has relatively clean and documented internal API,
designed to make implementation of new algorithms as simple as
possible (lost of details are abstracted).

** Contribution

All sorts of contributions are welcome - issues, unit tests,
documentation updates etc.

In addition there are several things that I wasn't able to implement
myself. If you are interested to solve one of there problems it will
be especially useful.

If you have any question about implementation details, API etc. you
can join my [[https://discord.gg/ZnBB4E][discord server]].

*** Earley parser

When implementing ~Earley~ parser I mostly followed [[http://loup-vaillant.fr/tutorials/earley-parsing/][this]] tutorial - it
has example implementation in ocaml and very nice explanation of most
algorithm parts, except for tree construction itself. My very limited
knowled of =ocaml= wasn't enough to fully rewrite it in =nim=.
Standalone rewrite is in [[file:src/hparse/earley_parser.nim]] - it does
not depend on any other library parts (can copy-paste on playground
and it will run just fine).

This parser algorithm is much more powerful compared to recursive
descent and even shift-reduce parsers. It can handle left recursion,
ambiguous and nullable rules.


** Unsolved problems


*** Fix tree after EBNF -> BNF rewriting
    :PROPERTIES:
    # :header-args:nim: :session ebnf-bnf-conversion
    :END:

Only recursive descent parsers can accept EBNF notation as-is. Every
other one requires conversion from EBNF to BNF (implemented, tested).
The problem is - this trasnformation changes shape of the parsed tree.
For example ~A ::= *(E)~ is converted to ~A ::= E1~ and ~E1 ::= Ɛ | E
E1~ - recursion is replaced with iteration.

#TODO add grammar transformation example
#TODO add parsed tree.

#TODO IDEA add support for ~block~ sessions - code will be wrapped
into ~block:~ (or alternative for other programming language).

#+caption: Comparison of ~LL(*)~ and table-driven LL(1) (w/o fixup)
#+begin_src nim :exports both
  initGrammarConst[NoCategory, string](grammar):
    A ::= "hello" & *(B) & "world"
    B ::= "!!"

  var toks = @[
    "hello", "!!", "!!", "!!", "world"].makeTokens().makeStream()

  let grammarVal =
    block:
      let tmp = grammar
      tmp.toGrammar()

  echo "Original grammar"
  echo grammarVal.exprRepr()
  echo "---\n"

  echo "Grammar converter to BNF"
  echo grammarVal.toBNF().exprRepr()
  echo "---\n"

  echo "Recursive descent tree"
  let parser1 = newLLStarParser[NoCategory, string, void](grammar)
  let tree1 = parser1.parse(toks)
  echo tree1.treeRepr()
  echo "---\n"

  toks.revertTo(0)

  echo "Table-driven parser tree without structure fixup"
  let parser2 = newLL1TableParser(
    grammarVal,
    dofixup = false,
    retainGenerated = true
  )
  let tree2 = parser2.parse(toks)
  echo tree2.treeRepr()
  echo "---\n"


  toks.revertTo(0)

  echo "Table-driven parser tree with fixup"
  let parser3 = newLL1TableParser(grammarVal, dofixup = true)
  let tree3 = parser3.parse(toks)
  echo tree3.treeRepr()
  echo "---\n"
#+end_src

#+RESULTS:
#+begin_example
Original grammar
A            ::= {'hello' & *(<B>) & 'world'}
B            ::= '!!'
---

Grammar converter to BNF
A  ::=
.0 | 'hello' & <A0_1> & 'world'

B  ::=
.0 | '!!'

A0_1  ::=
.0 | Ɛ
.1 | <B> & <@A0_1>

---

Recursive descent tree
+-> A
    +-> 'hello'
    +-> [ [ ... ] ]
    |   +-> B +-> '!!'
    |   +-> B +-> '!!'
    |   +-> B +-> '!!'
    +-> 'world'
---

Table-driven parser tree without structure fixup
+-> A
    +-> 'hello'
    +-> A0_1
    |   +-> B +-> '!!'
    |   +-> A0_1
    |       +-> B +-> '!!'
    |       +-> A0_1
    |           +-> B +-> '!!'
    +-> 'world'
---

Table-driven parser tree with fixup
+-> A
    +-> 'hello'
    +-> [ [ ... ] ]
    |   +-> B +-> '!!'
    |   +-> B +-> '!!'
    |   +-> B +-> '!!'
    +-> 'world'
---

#+end_example


Instead of ~*(B)~ new rule ~A0_1~ is introduced, with two possible
alternatives: either empty production (~Ɛ~) or ~B~, followed by ~A0_1~
again. How this conversion affects parse tree can be seen in the
output: instead of simple list of elements you get deeply nested tree
of ~A0_1~. This is fixed automatically when converting ~EBNF~ grammar
to ~BNF~ by adding 'splice' rule on every use of newly generated
pattern.

It kind of works (not really tested though), but I'm yet to figure how
to preserve original tree actions. For example, when converting
something like ~@*(@{!',' & <Element>})}~ to BNF it gets flattened
out, and it is not clear how to first splice things in ~!',' &
<Element>~, and then splice it again.


# #+caption: Grammar
# #+begin_src nim
# exampleConstGrammar:
#   A ::= *("hello")

# let llRecParser = newLL1RecursiveParser(grammar)
# let llTableParser = newLL1TableParser(grammar) # TODO add overloaded constructor for example
# #+end_src

#+begin_src nim :expors both
let tree1 = @["hello", "!!", "!!", "!!", "world"].exampleParse:
  A ::= "hello" & *(B) & "world"
  B ::= "!!"

echo "Recursive descent tree"
echo tree1.treeRepr()

echo "Table-driven parser tree"
let tree2 = @["hello", "!!", "!!", "!!", "world"].exampleParseBNF_noFix:
  A ::= "hello" & *(B) & "world"
  B ::= "!!"

echo tree2.treeRepr()
#+end_src

#+RESULTS:
#+begin_example
Recursive descent tree
+-> A
    +-> 'hello'
    +-> [ [ ... ] ]
    |   +-> B +-> '!!'
    |   +-> B +-> '!!'
    |   +-> B +-> '!!'
    +-> 'world'
Table-driven parser tree
+-> A
    +-> 'hello'
    +-> [ [ ... ] ]
    |   +-> B +-> '!!'
    |   +-> B +-> '!!'
    |   +-> B +-> '!!'
    +-> 'world'
#+end_example

* DSL error reporting

DSL for this library uses =hmisc/hexceptions= to generate *much*
better compilation errors in case of malformed DSL.

#+begin_src nim :exports both
let tree = "h".exampleParse:
  A ::= !@*("h")

echo tree.treeRepr()
#+end_src

#+RESULTS:
#+begin_example
Unexpected prefix: '!@*'

 2   let tree = "h".exampleParse:
 5:8   A ::= !@*("h")
             ^^^
             |
             Incorrect prefix combination



Raised in grammar_dsl.nim:105


 [CodeError:ObjectType]
#+end_example


NOTE: output is not colored in readme (because github [[https://github.com/github/markup/issues/369][fails]] to support
this basic feature *since 2014*), but it is colored by default
terminal (controlled by using ~-d:plainStdout~ compilation flag)
